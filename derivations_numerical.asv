%% CDC Math derivations
% Varying only one factor at a time 
% Simply resolves whole optimization problem at each new operating point
% for new solution & new cost/objective function value

function [dGamma_dTheta_nom,dF_dTheta_nom,error,max_dev,rel_sens_soln,rel_sens_cost,prob_mismatch] = derivations_numerical(theta,nominal,scenario_vals,devs)
% theta: Parameter w.r.t which we compute sensitivity
% nominal: Nominal parameter values
% scenario: Travel times, prices, utility coefficients etc. for hypothetical choice situation
% active: Which constraints are active
% devs: Amount of deviations/perturbations in parameter value (as %)

    %% Set nominal and scenario values
    alpha_val = nominal(1);
    beta_val = nominal(2);
    lambda_val = nominal(3);
    p_val = nominal(4);    
    
    b_sm = scenario_vals.b_sm;
    R_val = scenario_vals.R;
    lb = scenario_vals.lb;
    ub = scenario_vals.ub;
    u0 = scenario_vals.u0;
    x1 = scenario_vals.x1; % u_sm = x_sm + b * gamma
    x2 = scenario_vals.x2;
    
    %% Calculate symbolic derivatives and expressions
    gamma = sym('gamma'); 
    alpha = sym('alpha'); 
    beta = sym('beta'); 
    lambda = sym('lambda'); 
    p = sym('p'); 
    nu1 = sym('nu1'); 
    nu2 = sym('nu2');

    u1 = x1 + b_sm*gamma;
    u2 = x2 + b_sm*gamma;
    
    % Type of reference used
    if R_val == 'Best case'
        R = u2;
        U_sR = -exp(-(-log(p))^alpha) * lambda * (R - u1)^beta; 
        A_sR = -lambda*(R - u0)^beta;
        
    elseif R_val == 'Worst case'
        R = u1;
        U_sR = exp(-(-log(p))^alpha) * (u2 - R)^beta;
        A_sR = (u0 - R)^beta;
        
        % TODO: Need to finish cases for all possible static/dynamic reference types!
    end
    
    p_sR = exp(U_sR)/(exp(U_sR) + exp(A_sR));
    f = gamma*p_sR;

    % Derivatives wrt price
    p_sR_dot = diff(p_sR,gamma); % w.r.t gamma
    p_sR_ddot = diff(p_sR_dot,gamma);
    
    theta_val = str2sym(theta);
    
    if theta == 'alpha'
        theta_nom = alpha_val;
        f = subs(f,[alpha, beta, lambda, p],[theta_val, beta_val, lambda_val, p_val]);
        p_sR = subs(p_sR,[alpha, beta, lambda, p],[theta_val, beta_val, lambda_val, p_val]);
    elseif theta == 'beta'
        theta_nom = beta_val;
        f = subs(f,[alpha, beta, lambda, p],[alpha_val, theta_val, lambda_val, p_val]);
        p_sR = subs(p_sR,[alpha, beta, lambda, p],[alpha_val, theta_val, lambda_val, p_val]);
    elseif theta == 'lambda'
        theta_nom = lambda_val;
        f = subs(f,[alpha, beta, lambda, p],[alpha_val, beta_val, theta_val, p_val]);
        p_sR = subs(p_sR,[alpha, beta, lambda, p],[alpha_val, beta_val, theta_val, p_val]);
    else 
        theta_nom = p_val;
        f = subs(f,[alpha, beta, lambda, p],[alpha_val, beta_val, lambda_val, theta_val]);
        p_sR = subs(p_sR,[alpha, beta, lambda, p],[alpha_val, beta_val, lambda_val, theta_val]);
    end

    %% Calculate nominal optimum     
    gamma_ = sym('gamma_');
    
    options = optimoptions(@fmincon, 'Algorithm','interior-point');
    init = (lb + ub)/2;
    % Global minimum
    gs = GlobalSearch;
    
    problem = createOptimProblem('fmincon','objective',...
    -f_obj,'x0',init,'lb',lb,'ub',ub,'options',options);
    
    f_obj = subs(f,[gamma,theta_val],[gamma_,theta_nom]);

    delta_theta = theta_nom .* (devs./100); % theta - theta_nom
    theta_vals = theta_nom + delta_theta;
    perturbations = length(devs);
    gamma_opt = zeros(1,perturbations);
    f_opt = zeros(1,perturbations);

    for i = 1:perturbations
        f_obj = subs(f,[gamma,theta_val],[gamma_,theta_vals(i)]);
        f_obj = matlabFunction(f_obj);
        [gamma_opt(i), f_opt(i)] = run(gs,problem);
    end
    
    %% Relative sensitivities
    % Relative sensitivities will be equal/constant for all perturbations
    % if we use linear 1st order Taylor approximation
    rel_sens_soln = ((gamma_nom - opt_soln)./delta_theta).*100;
    rel_sens_cost_linear = ((f_nom_val - opt_cost_linear)./delta_theta).*100;
    rel_sens_cost_actual = ((f_nom_val - opt_cost_actual)./delta_theta).*100;    
    
    %% Estimate error in the 1st order approximation using 2nd order expansion 
    opt_cost2 = f_nom_val + (dGamma_dTheta_nom .* delta_theta) + 0.5 * d2F_dTheta2_nom .* (delta_theta).^2;
    error = ((opt_cost_linear - opt_cost2)./opt_cost2).*100; % Relative error (%) using 2nd order estimate as true value
   
    %% Local sensitivity plots
    figure(1)
    subplot(2,2,1)
    % Plug optimal solution into actual objective function (always valid)
    plot(theta_vals,opt_cost_actual);
    xlabel('Parameter value');
    ylabel('Optimal value of objective function ($)')    
    
    subplot(2,2,2)
    plot(theta_vals,opt_soln);
    xlabel('Parameter value');
    ylabel('Optimal solution or tariff ($)')
    
    subplot(2,2,3)
    plot(theta_vals,delta_soln);
    xlabel('Parameter value');
    ylabel('Deviation from nominal optimum solution')
    
    subplot(2,2,4)
    plot(theta_vals,delta_cost_actual);
    xlabel('Parameter value');
    ylabel('Deviation from nominal optimum objective')
    
    figure(2)
    % Linearized version (valid only for small perturbations)   
    subplot(2,1,1)
    plot(theta_vals,opt_cost_linear);
    xlabel('Parameter value');
    ylabel('Optimal value of (linearized) objective function ($)')
    
    subplot(2,1,2)
    plot(theta_vals,delta_cost_linear);
    xlabel('Parameter value');
    ylabel('Deviation from nominal optimum (linearized) objective')
    
    figure(3)
    plot(theta_vals,prob_actual);
    xlabel('Parameter value');
    ylabel('Subjective probability of acceptance')
       
    %% Global sensitivity analysis
    
    % Follow method from either (1) Buskens 2001 or (2) QP formulation
    
%     for i = 1:length(devs)
%         if devs(i) > max_devs
            
end